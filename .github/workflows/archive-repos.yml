name: Archive Unused Repositories

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (do not actually archive)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  schedule:
    # Run on the 1st of every month at 00:00 UTC
    - cron: '0 0 1 * *'

jobs:
  archive-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Archive unused repositories
        env:
          # Note: GITHUB_TOKEN doesn't have permission to archive repos.
          # For actual archival (dry_run=false), you need to create a PAT with 'repo' scope
          # and add it as REPO_ADMIN_TOKEN secret, then use: ${{ secrets.REPO_ADMIN_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'true' }}
        run: |
          #!/bin/bash
          set -e
          
          # Configuration
          OWNER="tyy130"
          MONTHS_INACTIVE=12
          
          # Calculate the date 12 months ago
          TWELVE_MONTHS_AGO=$(date -u -d "12 months ago" +%Y-%m-%dT%H:%M:%SZ)
          
          echo "üîç Scanning repositories for $OWNER..."
          echo "üìÖ Looking for repos not updated since: $TWELVE_MONTHS_AGO"
          echo "üèÉ Dry run mode: $DRY_RUN"
          echo ""
          
          # Get all repositories for the user (with pagination)
          REPOS=$(gh api --paginate "users/$OWNER/repos?per_page=100&type=owner" --jq '.[] | {name: .name, stars: .stargazers_count, updated_at: .updated_at, archived: .archived}')
          
          # Process each repository
          ARCHIVED_COUNT=0
          SKIPPED_COUNT=0
          
          while IFS= read -r repo; do
            REPO_NAME=$(echo "$repo" | jq -r '.name')
            STARS=$(echo "$repo" | jq -r '.stars')
            UPDATED_AT=$(echo "$repo" | jq -r '.updated_at')
            IS_ARCHIVED=$(echo "$repo" | jq -r '.archived')
            
            # Skip if already archived
            if [[ "$IS_ARCHIVED" == "true" ]]; then
              echo "‚è≠Ô∏è  Skipping $REPO_NAME (already archived)"
              ((SKIPPED_COUNT++))
              continue
            fi
            
            # Check if repo has 0 stars and hasn't been updated in 12 months
            # Note: ISO 8601 date strings (YYYY-MM-DDTHH:MM:SSZ) support lexicographic comparison
            if [[ "$STARS" -eq 0 && "$UPDATED_AT" < "$TWELVE_MONTHS_AGO" ]]; then
              echo "üì¶ Found candidate for archival: $REPO_NAME"
              echo "   Stars: $STARS"
              echo "   Last updated: $UPDATED_AT"
              
              if [ "$DRY_RUN" = "false" ]; then
                echo "   üóÉÔ∏è  Archiving..."
                if ERROR_OUTPUT=$(gh api \
                  --method PATCH \
                  -H "Accept: application/vnd.github+json" \
                  "repos/$OWNER/$REPO_NAME" \
                  -f archived=true 2>&1); then
                  echo "   ‚úÖ Archived!"
                else
                  echo "   ‚ùå Failed to archive: $ERROR_OUTPUT"
                fi
              else
                echo "   ‚ÑπÔ∏è  Would archive (dry run mode)"
              fi
              
              ((ARCHIVED_COUNT++))
            else
              echo "‚úì Keeping $REPO_NAME (Stars: $STARS, Updated: $UPDATED_AT)"
              ((SKIPPED_COUNT++))
            fi
            
          done < <(echo "$REPOS" | jq -c '.')
          
          echo ""
          echo "üìä Summary:"
          echo "   Repositories processed: $((ARCHIVED_COUNT + SKIPPED_COUNT))"
          echo "   Repositories archived/would archive: $ARCHIVED_COUNT"
          echo "   Repositories kept: $SKIPPED_COUNT"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "‚ÑπÔ∏è  This was a dry run. To actually archive repositories, run with dry_run=false"
          fi
